## Desafio #03 - Clean Architecture

O desafio consiste em adicionar o usecase de listagem de pedidos (orders).

#### üñ•Ô∏è Detalhes Gerais:

O novo usecase dever√° ser utilizado para expor as informa√ß√µes, na medida em que forem requisitadas:
- Em endpoint (GET /order)
- Em um novo service ListOrders com gRPC
- Em uma nova query ListOrders com GraphQL

> Como adicional, ser√° tamb√©m poss√≠vel consultar um pedido espec√≠fico, atrav√©s de um endpoint (GET /order/:id), um service `ListOrderById` com gRPC e uma query `listOrder` com GraphQL.

#### üóÇÔ∏è Estrutura do Projeto
    .
    ‚îú‚îÄ‚îÄ cmd                # Entrypoints da aplica√ß√£o
    ‚îÇ    ‚îî‚îÄ‚îÄ ordersystem   
    ‚îÇ           ‚îú‚îÄ‚îÄ main.go       ### Entrypoint principal
    ‚îÇ           ‚îú‚îÄ‚îÄ wire.go       ### Inje√ß√£o de depend√™ncias
    ‚îÇ           ‚îî‚îÄ‚îÄ .env          ### Arquivo de parametriza√ß√µes globais
    ‚îú‚îÄ‚îÄ configs            # helpers para configura√ß√£o da aplica√ß√£o (viper)
    ‚îú‚îÄ‚îÄ internal
    ‚îÇ    ‚îú‚îÄ‚îÄ domain        # Core da aplica√ß√£o
    ‚îÇ    ‚îÇ      ‚îú‚îÄ‚îÄ repository    ### Interfaces de reposit√≥rio
    ‚îÇ    ‚îÇ      ‚îî‚îÄ‚îÄ entity        ### Entidades de dom√≠nio
    ‚îÇ    ‚îú‚îÄ‚îÄ application   # Implementa√ß√µes de casos de uso e utilit√°rios
    ‚îÇ    ‚îÇ      ‚îî‚îÄ‚îÄ usecase       ### Casos de uso da aplica√ß√£o
    ‚îÇ    ‚îú‚îÄ‚îÄ infra         # Implementa√ß√µes de reposit√≥rios e conex√µes com servi√ßos externos
    ‚îÇ    ‚îÇ      ‚îú‚îÄ‚îÄ database      ### Implementa√ß√µes de reposit√≥rio
    ‚îÇ    ‚îÇ      ‚îú‚îÄ‚îÄ graph         ### Implementa√ß√µes e c√≥digos gerados para a API GraphQL
    ‚îÇ    ‚îÇ      ‚îú‚îÄ‚îÄ grpc          ### Implementa√ß√µes e c√≥digos gerados para a API gRPC
    ‚îÇ    ‚îÇ      ‚îî‚îÄ‚îÄ web           ### Implementa√ß√µes e c√≥digos gerados para a API Rest
    ‚îÇ    ‚îî‚îÄ‚îÄ event         # Implementa√ß√µes de eventos e listeners
    ‚îú‚îÄ‚îÄ pkg                # Pacotes reutiliz√°veis utilizados na aplica√ß√£o
    ‚îú‚îÄ‚îÄ init_db.sql        # Script de inicializa√ß√£o do banco de dados
    ‚îî‚îÄ‚îÄ README.md

#### üß≠ Parametriza√ß√£o
A aplica√ß√£o servidor possui um arquivo de configura√ß√£o `cmd/ordersystem/.env` onde √© poss√≠vel definir os par√¢metros de timeout e URL's das API's para busca das informa√ß√µes do endere√ßo.

```
DB_DRIVER=mysql                 # Database driver
DB_HOST=localhost               # Database host (More database details in docker-compose)
DB_PORT=3306                    # Database port
DB_USER=root                    # Database user
DB_PASSWORD=root                # Database password
DB_NAME=fc_challenge            # Database name
WEB_SERVER_PORT=:8000           # Web server port
GRPC_SERVER_PORT=50051          # gRPC server port
GRAPHQL_SERVER_PORT=8080        # GraphQL server port
```

> üí° Os recursos externos MySQL e RabbitMQ s√£o executador por meio de imagens Docker. Caso necess√°rio alterar, poder√° ser necess√°rio revisar as vari√°veis de ambiente no arquivo `.env`.

#### üöÄ Execu√ß√£o:
Antes de iniciar, √© necess√°rio instalar as depend√™ncias do projeto. Para isso, execute o comando abaixo:
```bash
$ go mod tidy
```

Para executar a aplica√ß√£o, existem duas op√ß√µes:

#### 1. Utilizando o `makefile`:
Para facilitar a execu√ß√£o da aplica√ß√£o, todas as etapas necess√°rias foram adicionadas ao makefile. Para executar a aplica√ß√£o, basta executar o comando abaixo:
```bash
$ make run
```

#### 2. Executando manualmente:
Caso a op√ß√£o anterior falhe, √© poss√≠vel executar a aplica√ß√£o manualmente, seguindo os passos abaixo:
```bash
$ docker-compose up -d
$ cd cmd/ordersystem
$ go run ./main.go ./wire_gen.go
```

> üí° Os comandos acima poder√£o falhar caso alguma das portas utilizadas estejam em uso. Caso isso ocorra, ser√° necess√°rio alterar as portas no arquivo `.env` ou encerrar os processos que est√£o utilizando as portas (8000, 8080, 50051, 3306, 5672 e 15672).

### üìù Usando as API's:

#### 1. REST API:

- **Criar um pedido:**
```bash
$ curl --location 'http://localhost:8000/order' \
--header 'Content-Type: application/json' \
--data '{
    "id": "aff0-2223-8842-fe215",
    "price": 66.5,
    "tax": 1.1
}'
```

- **Listar todos os pedidos (exemplo):**
```bash
$ curl --location 'http://localhost:8000/order'
```

- **Consultar um pedido (exemplo):**
```bash
$ curl --location 'http://localhost:8000/order/<<OrderId>>'
```

#### 2. GraphQL API:

> Para utilizar a API GraphQL, √© necess√°rio acessar o playground dispon√≠vel em `http://localhost:8080/`.

- **Criar um pedido (exemplo):**
```graphql
mutation createOrder {
    createOrder(input:{id: "aff0-2223-8842-fe214",Price:854.1, Tax: 0.8}){
        id
    }
}
```

- **Listar todos os pedidos (exemplo):**
```graphql
query listOrders {
    listOrders {
        id
        Price
        Tax
        FinalPrice
    }
}
```

- **Consultar um pedido (exemplo):**
```graphql
query findOrder {
    listOrder(id:"aff0-2223-8842-fe215"){
        id
        Price
        Tax
        FinalPrice
    }
}
```

#### 3. gRPC API:

> Para a utiliza√ß√£o da API gRPC, foi utilizado o Evans gRCP client. Para instalar, siga as instru√ß√µes dispon√≠veis em: [evans - install](https://github.com/ktr0731/evans?tab=readme-ov-file#installation)


- **Iniciando Evans:**
```bash
$ evans -r repl --host localhost --port 50051
 
localhost:50051>  package pb
pb@localhost:50051>  service OrderService
```

- **Criar um pedido (exemplo):**
```bash
pb.OrderService@localhost:50051> call CreateOrder
id (TYPE_STRING) => 1
price (TYPE_FLOAT) => 100
tax (TYPE_FLOAT) => 50
{
  "finalPrice": 150,
  "id": "1",
  "price": 100
}
```

- **Listar todos os pedidos (exemplo):**
```bash
pb.OrderService@localhost:50051> call ListOrders
{
  "orders": [
    {
      "finalPrice": 150,
      "id": "1",
      "price": 100,
      "tax": 50
    }
  ]
}
```

- **Consultar um pedido (exemplo):**
```bash
pb.OrderService@localhost:50051> call ListOrderById
id (TYPE_STRING) => aff0-2223-8842-fe214
{
  "finalPrice": 854.9,
  "id": "aff0-2223-8842-fe214",
  "price": 854.1,
  "tax": 0.8
}
```